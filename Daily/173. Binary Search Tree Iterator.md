###### Medium / Tree

### 173. Binary Search Tree Iterator

Implement the ```BSTIterator``` class that represents an iterator over the in-order traversal of a binary search tree (BST):

* ```BSTIterator(TreeNode root)``` Initializes an object of the ```BSTIterator``` class. The ```root``` of the BST is given as part of
the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.
* ```boolean hasNext()``` Returns ```true``` if there exists a number in the traversal to the right of the pointer, otherwise returns```false```.
* ```int next()``` Moves the pointer to the right, then returns the number at the pointer.
Notice that by initializing the pointer to a non-existent smallest number, the first call to ```next()``` will return the smallest element in the BST.

You may assume that ```next()``` calls will always be valid. That is, there will be at least a next number in the in-order traversal when ```next()``` is called.

 

###### Example 1:
![](https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png)
```
Input
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
Output
[null, 3, 7, true, 9, true, 15, true, 20, false]

Explanation
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // return 3
bSTIterator.next();    // return 7
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 9
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 15
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 20
bSTIterator.hasNext(); // return False
```

###### Constraints:

* The number of nodes in the tree is in the range [1, 10^5].
* 0 <= Node.val <= 10^6
* At most 10^5 calls will be made to hasNext, and next.
 

###### Follow up:

* Could you implement next() and hasNext() to run in average O(1) time and use O(h) memory, where h is the height of the tree?

***

#### Recursive
```java
class BSTIterator {
    Queue<Integer> q = new LinkedList<>();
    public BSTIterator(TreeNode root) {
        inOrder(root);
    }
    
    public void inOrder(TreeNode root) {
        if (root == null) return;
        inOrder(root.left);
        q.add(root.val);
        inOrder(root.right);
    }
    
    public int next() {
        return q.poll();
    }
    
    public boolean hasNext() {
        return !q.isEmpty();
    }
}
```
***
#### Iterative / Stack
```java
class BSTIterator {

    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = null;
    
    public BSTIterator(TreeNode root) {
        cur = root;
    }
    
    /** @return the next smallest number */
    public int next() {
        int res = -1;
        while (cur != null || !stack.isEmpty()) {
            while (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.pop();
            res = cur.val;
            cur = cur.right;
            break;
        }
        return res;
    }
    
    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return cur != null || !stack.isEmpty();
    }
}
```
