###### Medium / Binary Search / Depth First Search / Top Left To Bottom Right Path

### 1631. Path With Minimum Effort

You are a hiker preparing for an upcoming hike.   

You are given `heights`, a 2D array of size `rows x columns`, where `heights[row][col]` represents the height of cell `(row, col)`.    
You are situated in the top-left cell, `(0, 0)`, and you hope to travel to the bottom-right cell, `(rows-1, columns-1)` (i.e., 0-indexed).   
You can move **up, down, left, or right,** and you wish to find a route that requires the minimum **effort**.   

A route's **effort** is the **maximum absolute difference** in heights between two consecutive cells of the route.

Return _the minimum **effort** required to travel from the top-left cell to the bottom-right cell._


###### Example 1:
```
Input: heights = [[1,2,2],[3,8,2],[5,3,5]]
Output: 2
Explanation: The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.
This is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.
```

###### Example 2:
```
Input: heights = [[1,2,3],[3,8,4],[5,3,5]]
Output: 1
Explanation: The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5].
```

###### Example 3:
```
Input: heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]
Output: 0
Explanation: This route does not require any effort.
```

###### Constraints:
- `rows == heights.length`
- `columns == heights[i].length`
- `1 <= rows, columns <= 100`
- `1 <= heights[i][j] <= 106`

***

###### Binary Search and BFS

```java
    private int[] d = {0, 1, 0, -1, 0};
    
    // use Binary Search to find the right effort
    public int minimumEffortPath(int[][] heights) {
        int lo = 0, hi = 1_000_000;
        while (lo < hi) {
            int effort = lo + (hi - lo) / 2;
            if (isPath(heights, effort)) {
                hi = effort;
            }else {
                lo = effort + 1;
            }
        }
        return lo;
    }
    
    // try if there is a path that could takes up to a given effort 
    // to connect the top left cell to bottom right cell
    private boolean isPath(int[][] h, int effort) {
        int m = h.length, n = h[0].length;
        Queue<int[]> q = new LinkedList<>();
        q.offer(new int[2]);
        Set<Integer> seen = new HashSet<>();
        seen.add(0);
        while (!q.isEmpty()) {
            int[] cur = q.poll();
            int x = cur[0], y = cur[1];
            if (x == m - 1 && y == n - 1) {
                return true;
            }
            for (int k = 0; k < 4; ++k) {
                int r = x + d[k], c = y + d[k + 1];
                if (0 <= r && r < m && 0 <= c && c < n && effort >= Math.abs(h[r][c] - h[x][y]) && seen.add(r * n + c)) {
                    q.offer(new int[]{r, c});
                }
            } 
        }
        return false;
    }
```
> Time: O(m * n * log(Max)), space: O(m * n), where m, n and Max are the dimensions and the max absolute difference among the matrix.

[via: LC Discuss](https://leetcode.com/problems/path-with-minimum-effort/discuss/909002/JavaPython-3-Binary-Search-and-BFS-w-brief-explanation-and-analysis.)

###### DFS get LTE

DFS is a very intuitive solution but gets the LTE.  

Theoretically, the DFS gets the time complexity of O(V + E), where V is #vertices and E is #edges.  

In this case, V is m * n, E is approximately 4 * m * n, where m is #rows and n is #cols.

Time: maybe O(m * n)?

Fell free to correct me.  

